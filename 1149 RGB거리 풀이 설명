/*
RGB 거리문제를 풀때 한가지 기억해야할 전제 조건이 있다.



N까지의 누적 최소합 = N-1까지의 누적최소합 + N번째의 최소값

이라는 것이다. 둘중 어느 하나라도 최소값이 아닐 경우 N번째까지의 누적 값이 최소값이라고 보장할 수 없게된다.



왜 이런지 생각해보면 아래와 같다.

만약 N-1까지의 누적값이 최소가 아니라면 최소값은 분명 존재할 것이고 이때 각각 N번째 최소값을 더한다면 N까지의 누적값이 최소값이 아니게 된다.



이를 이용하여 세울 수 있는 점화식은 2가지가 존재한다.



1. 2차원 배열을 이용하여 점화식 도출 int DP[1000][3]

2. 1차원 배열을 이용하여 점화식 도출 int DP[3]





이제 점화식을 세울 차례이다.

점화식을 세우기 앞서 문제를 요약해보면 아래와 같다.



1 ~ N 까지의 집이 일렬로 존재하는데 이 집들을 각각 R, G, B의 색상중 하나로 칠하려 한다.

이때 이웃간에 같은 색으로 칠하지 않고자 할 때의 최소비용을 구하는 문제이다.



우선 구하고자 하는것이 N까지의 R,G,B로 칠할 최소 비용 이므로 1차원적으로 간단히 세우면 아래와 같다.



DP[N] = N까지의 최소 색칠 비용



하지만 위 일차원 배열만으로는 점화식을 도출하기 힘드므로 생각을 약간 비틀어서 바꾸어 보면

DP[N][3] = N번째를 enum { R, G, B } 중 하나로 색칠 할때의 최소 비용



위와 같이 바꾸게 되면 점화식은 상당히 간단해 진다.

i + 1번째 집까지의 최소 색칠 비용을 구한다 하면 경우의 수는 총 3가지가 나오게 된다.





i+1번째 까지의 최소 색칠 비용 = R : min(i번째 G색상 까지의 최소 합, i번째 B색상 까지의 최소 합) + R 비용

i+1번째 까지의 최소 색칠 비용 = G : min(i번째 R색상 까지의 최소 합, i번째 B색상 까지의 최소 합) + G 비용

i+1번째 까지의 최소 색칠 비용 = B : min(i번째 R색상 까지의 최소 합, i번째 G색상 까지의 최소 합) + B 비용



이제 이 경우의 수를 기준으로 점화식을 세우면 아래와 같이 나오게 된다.

편의상 N번째 집의 R색을 칠할 비용을 COLOR[N][0], G색을 칠할 비용을 COLOR[N][1], B색을 칠할 비용을 COLOR[N][2] 라 정의 하면,



DP[i][0] = min(DP[i-1][1], DP[i-1][2]) + COLOR[i][0];

DP[i][1] = min(DP[i-1][0], DP[i-1][2]) + COLOR[i][1];

DP[i][2] = min(DP[i-1][0], DP[i-1][1]) + COLOR[i][2];





이러한 방식의 점화식을 세우는 것도 가능하지만 사실 이보다 더 적은양의 공간복잡도를 가지도록 하는 것이 가능하다.



위 2차원 점화식에서 주의깊게 봐야할 부분이 2가지 있다.

첫번째는 이 문제에 대한 풀이를 설명할 당시 말했던 누적 최소값의 정의이다.

두번째는 i번째 까지의 최소 색칠비용을 구하고자 할때 i-1 까지의 최소 색상 비용이 사용된다는 점이다.



즉 i번째 까지의 누적 최소비용을 구하기 위해 i-1까지의 누적 색상비용만을 사용하게 되며,

해당 점화식에서 i-2나 i-3까지의 누적 최소비용은 알 필요가 없다는 점이다.





이를 이용하면 int DP[3] 만을 이용하여 점화식 도출이 가능한데 그 방식은 아래와 같다.

DP[0] = 마지막에 R색상을 칠 할 경우의 누적 최소비용
DP[1] = 마지막에 G색상을 칠 할 경우의 누적 최소비용
DP[2] = 마지막에 B색상을 칠 할 경우의 누적 최소비용


이를 pseudo code(슈도코드)로 작성하면 아래와 같다.





COLOR[N][3] = N번째 집의 0: R, 1: G, 2: B 색상으로 칠할 각각의 비용



int answer = 0;

for i = 1 ... N

    DP[0] = min(DP[1], DP[2]) + COLOR[i][0];

    DP[1] = min(DP[0], DP[2]) + COLOR[i][1];

    DP[2] = min(DP[0], DP[1]) + COLOR[i][2];



    answer = min(DP[0], min(DP[1], DP[2]));
*/
